2022/11/14

# 动态规划问题

rongtianfu@gmail.com

## 特点简述

动态规划问题本质上与分治问题类似，但是动态规划问题划分得到的子问题往往不是互相独立的（分支问题划分的子问题是彼此独立的）。在分治问题中，可以记下某些子问题的结果，这样以后如果再次遇到这个问题，就可以直接调用。在动态规划问题中，由于子问题之间往往是有联系的，所以必须记载子问题的结果，从而方便进行优化（例如，比较）。

动态规划问题具有两个非常重要的特点：

1. 最优子结构：指的是较大规模问题的最优解中包含较小规模问题的最优解，因此可以通过自底向上的方法来进行求解
2. 重叠子问题：有些子问题在问题的求解过程中反复计算，这是因为为了得到某一规模问题的“最优解”，往往需要遍历每一个子问题的解，因此为了优化程序，我们必须记下每个子问题的解，防止重复计算

动态规划问题的处理步骤：

1. 找出最优解的性质，并刻画其结构特征
2. 递归地定义最优值
3. 以自底向上的方法来计算最优值
4. 根据计算最优值时得到的信息来构造最优解



## 矩阵连乘问题

> 给定$n$个矩阵，这$n$个矩阵可以连乘（$A_1A_2\cdots A_n$），试对这个式子加括号使得在该括号定义的运算次序下下的计算量最小（计算量用乘法次数来进行衡量）

***第一步：分析最优解的性质***

什么样的解是最优解？最优解具有什么样的结构？假设连乘$A_1\cdots A_n$在$i$处断开，那么$A_1\cdots A_n$的计算量应该是$A_1\cdots A_{i-1}$的计算量加上$A_i\cdots A_n$的计算量再加上这两者结合时的计算量。此处的$i$应该是最优的，如果存在另一个$j$，使得$A_1\cdots A_n$在$j$处断开时的总计算量最小，那么应该取这个$j$。

经过上面的分析，我们知道，$A_1\cdots A_n$需要在“最优处”断开，而断开得到的两个子连乘部分又需要在各自的最优$i$断开，以此不断向下分解，直到得到的是单个矩阵。

***第二步：递归地定义最优值***

我们用二维数组（动态规划常常使用二维数组来进行刻画？）来刻画这个问题，`cost[i][j]`表示连乘$A_1\cdots A_j$在$i$处断开的计算量，那么就有：
$$
\text{cost[i][j]}=
\begin{cases}
0& \text{i=j}\\
\min_{k}\{\text{cost[i][k]+cost[k+1][j]}+p_{i-1}p_kp_j\}& \text{i<j}
\end{cases}
$$
这样就完成了最优值的定义。

***第三步：自底向上地计算最优值***

为了降低计算量，我们需要自底向上地计算最优值，那么采用什么样的计算顺序？由于每个比较长的连乘都是由两个较短的连乘“连接”得到的，因此我们可以按照连乘的长度来进行计算，即：

1. 首先计算长度为$1$的连乘，即`cost[i][i]=0`（$1\leq i\leq n$）
2. 然后计算长度为$2$的连乘，即`cost[i][i+1]`（$1\leq i\leq n-1$）
3. 然后计算长度为$3$的连乘，即`cost[i][i+2]`（$1\leq i\leq n-2$）
4. $\dots$
5. 最后计算长度为$n$的连乘，即`cosy[i][i+(n-1)]`（$1\leq i\leq n-(n-1)$）

这么做是因为计算长度为$l$的连乘只会用到长度小于$l$的连乘，而这些连乘已经计算过了。

***第四步：根据相关信息构造最优解***

我们需要记下每一步断开的取值，可以通过引入一个新的二维矩阵`seg[i][j]`来表示$A_i\cdots A_j$在哪里断开是最优的，最后在得到`seg[1][n]`之后只需要不断回溯并输出即可。

***源代码***

略，见对应的程序文件。



## 最长公共子序列

> 给定两个序列$X$和$Y$，子序列指的是从序列中选择出下标依次递增的一串字符，两个序列的最长公共子序列在两个序列中的下标集可以不相同，试找出两个序列$X$和$Y$的最长公共子序列

***第一步：分析最优解的性质***

参考多年做数学题的经验，这两个序列是对称的，因此“固定一个而在另一个中寻找最长子序列”的思路往往是不可行的（因为这种思路将两个序列置于了不平等的位置，虽然有时候“定一动一”的思路在数学上有时候有奇效，但这是在对称思考完全无效或者很困难的时候才会考虑的）。

如何平等地、同时地来考虑两个序列？假定两个序列分别为$X_1\cdots X_m$和$Y_i\cdots Y_n$，最长公共子序列为$Z_1\cdots Z_k$，则有：

- 如果$X_m=Y_n$，那么$Z_1\cdots Z_{k-1}$是$X_1\cdots X_{m-1}$和$Y_1\cdots Y_{n-1}$的最长公共子序列
- 如果$X_m\neq Y_n$，且$Z_k\neq X_m$，那么$Z_1\cdots Z_k$是$X_1\cdots X_{m-1}$和$Y_1\cdots Y_n$的最长公共子序列
- 如果$X_m\neq Y_n$，且$Z_k\neq Y_n$，那么$Z_1\cdots Z_k$是$X_1\cdots X_m$和$Y_1\cdots Y_{n-1}$的最长公共子序列

***第二步：递归地定义最优值***

需要明确的是，直接记载子序列中有什么元素不是容易的事（除非用自定义的结构体），从上一题可以受到这样的启发：动态规划问题中往往需要一个“度量”来衡量什么样的解的优秀的，在动态规划本体中需要考虑的问题是如何优化这个“度量”，而具体的解的内容则往往作为“副产品”出现。这一启发是非常重要的，在上一题中，“度量”就是计算次数，目标是要最小化这个计算次数；而在本题，“度量”是子序列的长度，目标是要最大化这个长度。

因此，使用二维数组`max_length[i][j]`表示$X$序列取$X_1\cdots X_i$和$Y$序列取$Y_1\cdots Y_j$时两者的最长子序列，那么有：
$$
\text{max\_length[i][j]}=
\begin{cases}
0 & i=0~\text{or}~j=0\\
\text{max\_length[i-1][j-1]+1} & i,j>0~\text{and}~X_i=Y_j\\
\max\{\text{max\_length[i-1][j]},\text{max\_length[i][j-1]}\} & i,j>0~\text{and}~X_i\neq Y_j
\end{cases}
$$
最优值定义完毕。

***第三步：自底向上地求解最优值***

如果问题比较简单的话，可以直接利用递归式进行递归求解。动态规划问题之所以建议采取自底向上地求解最优值的主要原因是：保证下一步更大规模的问题的求解仅会使用到已经求解的问题（理论上，这一点由最优子结构性质保证，如果不满足这条要求，自然不能使用动态规划方法来求解），从而保证复杂度在可接受的范围内。

因此，计算步骤可以叙述如下：

1. 取`i=1`，计算`j=1,2,...,n`时两序列的最长子序列长度
2. 取`i=2`，计算`j=1,2,...,n`时两序列的最长子序列长度
3. 取`i=1`，计算`j=1,2,...,n`时两序列的最长子序列长度
4. $\dots$
5. 取`i=m`，计算`j=1,2,...,n`时两序列的最长子序列长度

这样就可以保证每次计算最长子序列长度的时候，使用到的数据都是已经得到的

***第四步：根据相关信息构造最优解***

以上我们只求出了最长公共子序列的长度是多少，并未求出子序列由哪些字符构成。这里需要引入另一个二维数组`ans_from[i][j]`表示当`max_length[i][j]`取某长度时，这一长度是从哪种递归情况得到的（对应递归式中的后三种情况，$0$情况不看）。

在有了`ans_from`数组之后，我们还是不知道子序列到底有哪些内容，事实上，可以利用相应的递归情况来逐一构造出子序列的内容，例如：

- 如果`ans_from[i][j]=1`，那么我们就知道子序列中一定包含`x[i]`（或者相等的`y[j]`）（从递归式的第二种情况而来），然后看`ans_from[i-1][j-1]`
- 如果`ans_from[i][j]=2`，那么需要继续看`max_length[i-1][j]`（从递归式的第三种情况的第一个分情况而来）
- 如果`ans_from[i][j]=3`，那么需要继续看`max_length[i][j-1]`（从递归式的第三种情况的第二个分情况而来）

按照以上思路即可得到最优子序列的内容，如果有需要的话，还可以输出最优子序列在两个序列中的下标集合。

***源代码***

略，见对应的源文件。



## 最大字段和

> 给定一串数字（可能为正数、复数或零），取其中连续的若干个数字，并求和，使得到的和最大，试解决此问题

***第一步：分析最优解的性质***

设$b_i$是这串数字中以$a_i$结尾的连续数字串求和的最大值，那么，最优解具有下面的特点：

- 如果$a_{i+1}+b_i\geq a_{i+1}$，那么$b_{i+1}=a_{i+1}+b_i$，此时连续数字串“可以保持增长”
- 如果$a_{i+1}+b_i\leq a_{i+1}$，那么$b_{i+1}=a_{i+1}$，此时以$a_{i+1}$作为最后一个数字的连续数字串不能包括前面的数字，这会使得求和值反而更小

***第二步：递归地定义最优值***

根据前面的分析，可与很容易地写出$b_i$的递归定义，注意其中的判断条件可以进一步简化为$b_i$的正负判断：
$$
\text{b[i]}=
\begin{cases}
\text{a[i]} & \text{b[i-1]}<0\\
\text{a[i]}+\text{b[i-1]} & \text{b[i-1]}\geq0
\end{cases}
$$
最优值定义完毕。

***第三步：自底向上地求解最优值***

根据前面的分析可以很容地完成`b`数组的求解。

***第四步：根据相关信息构造最优解***

只需要遍历一次`b`数组即可知道最大字段和是多少，如果需要进一步求解连续数字段是从哪到哪，那么可以设一个新的`c`数组，其中`c[i]`的内容为以$a_i$为结尾的连续数字段的开始位置是什么，这个`c`数组可以随`b`数组一起求解出来。

***源代码***

略，见对应的源文件。



## 01背包

> 有$N$件物品和一个容量为$V$的背包，每件物品需要容量为$C_i$，得到的价值是$W_i$，试合理规划放入物品使价值总和最大

***第一步：分析最优解的性质***

对于每一件物品，显然有放入和不放入两种选择，如果令$f(i,j)$为前$i$件物品和容量为$j$时的最大价值，那么显然有：
$$
f(i,j)=\max\{f(i-1,j),f(i-1,j-C_i)+W_i\}
$$
其中前一种情况对应不放入第$i$件物品，第二种情况对应于放入第$i$件物品。

***第二步：递归地定义最优值***

引入`f[i][j]`二维数组和`w[i]`与`c[j]`两个一维数组，递归定义与上面一样。

***第三步：自底向上地求解最优值***

略。

***第四步：根据相关信息构造最优解***

如何得知背包中到底放入了哪些物品？可以采取和最长共子序列类似的思路，用一个二位数组`ans_from[i][j]`记下对应问题的解对应的情况：

- `ans_from[i][j]=0`表示第$i$件物品没有放入背包
- `ans_from[i][j]=1`表示第$i$件物品放入了背包

这样只需要一次从`f[总物品数量][总空间数量]`开始的跟踪就可以得知到底哪些元素装入了背包。

***源代码***

略，见对应的源文件。

***空间优化***

在之前的讨论中，我们定义的是二维数组`f[i][j]`，但实际上这是不必要的。注意到每次循环实际上只用到了与$i$相邻的$i-1$这一维的数组，所以实际上很多数据是不必要存储的。可以仅使用一维数组来进行求解，详见《背包九讲》。

***一个小细节***

在背包问题中，可能存在这样一种限制：背包恰好装满，这时需要在数组初始化的时候做一些手脚，将除了`f[0][j]`之外的所有值都初始化为负无穷、将`f[0][j]`初始化为$0$（对于空间优化后的一维情形，将`f[0]`初始化为$0$，其他都初始化为负无穷），然后按照正常思路做下去就行了，这样处理的原因详见《背包九讲》。

是否存在这样一种情况：要求背包恰好装满，求最优解，但是题目给出的数据不可能“恰好装满”背包？应该是可能的？



## 完全背包

> 有$N$种物品和一个容量为$V$的背包，每件物品需要容量为$C_i$，得到的价值是$W_i$，试合理规划放入物品使价值总和最大

***第一步：分析最优解的性质***

和经典01背包问题不同的是，这里每种物品有无数件可以装入。所以$f(i,j)$中的$i$表示第$i$种而不是第$i$个，这样则有：
$$
f(i,j)=\max\{f(i-1,j),f(i,j-C_i)+W_i\}
$$
其中前一种情况对应于第$i$种物品不装入，后一种情况对应于第$i$种物品装入。

***第四步：根据相关信息构造最优解***

和经典01背包类似，这里也使用一个二维数组`ans_from[i][j]`来辅助解决这个问题：

- `ans_from[i][j]=0`表示第$i$件物品没有装入背包
- `ans_from[i][j]=k`表示第$i$件物品装入了$k$件

***源代码***

略，见对应的源文件。



## 多重背包

> 有$N$种物品和一个容量为$V$的背包，第$i$种物品最多有$M_i$件可用，每件物品所需空间为$C_i$、价值为$W_i$，试解决此问题

***第一步：分析最优解的性质***

这道题可以转换成01背包进行求解，由于每件物品都是有限的，因此可以将“一组同类物品”拆分成互相没有关系的一系列物品，然后使用基础的01背包即可进行求解！



## 混合背包

> 这一问题指的是将前面的三种背包进行组合，不同种类的物品有不同的限制，试求解此问题

这一问题是容易求解的，例如：

- 如果不含完全背包（只含01背包或者多重背包或其中一者），那么可以转化为经典的01背包进行求解
- 如果含有完全背包（并且有01背包，如果含多重背包则转成01背包），如果采用优化后的一维数组`f[i]`（而不是经典的二维数组`f[i][j]`）进行求解，那么代码中只有一处不同，因此可以通过一则`if`判断来进入到不同的二重循环中进行求解



## 二维费用的背包问题

> 如果每件物品有两种费用$C_i$和$D_i$，即：在放入物品时必须同时付出这两种代价，试求解此问题？

一个显然的思路就是使用三维数组（或优化后的二维数组）进行求解，代码上实现是容易的，此处不再单独说明。但是需要注意“二维费用”这一概念可能通过隐含的方式给出，例如：总物品的限制，相当于给每件物品一个代价$D_i=1$（$i=1,2,\cdots, n$）且总数限制为$U$。

一个思路是非常重要的：对于动态规划问题，如果引入了新的限制，那么一个常用的思路就是引入一个新的维度来处理这一限制。



## 分组背包

> 一共有$N$件物品和一个容量为$V$的背包，第$i$件物品的费用是$C_i$、价值是$W_i$，这些物品可划分为$K$组，没组中的物品互相冲突（即最多选一件），试解此问题

此问题需要对第$k$组物品进行处理：该组物品选或不选、以及如果选那么选择哪一个是最优的处理？



## 电路布线

> 一块电路板的上下两端各有$n$个接线柱，现给定上下接线柱之间的连接方式（一定是一对一连接），试求出哪些接线柱之间的连接彼此不相交且接线数量最多

***第一步：分析最优解的性质***

两条线$(a,\pi(a))$和$(b,\pi(b))$相交当且仅当$a<b$且$\pi(a)>\pi(b)$（或者反过来）。

在动态规划问题中，为了衡量解的“优秀程度”，我们必须引入一个标记解的度量值，一旦这个度量值到达某个最值，那么解也就达到了最优目标。在本题中，为了求最大的“不相交集合”，一个常见的思路就是通过合法（不相交）的接线数量的多少来衡量解之间的“优秀程度”，并以此作为动态规划的目标。

我们引入一个二元函数$\text{size}[i][j]$来标记上接线柱选第$i$个和下接线柱选第$j$个的时候最多的不相交的接线数量。固定$i$不变，并依次增加$j$的值（从$j=1$开始直到$j=n$），可以分析如下：

1. 当$j<\pi(i)$时，接线$(i,\pi(i))$不可能被加入到“不相交集合”中
2. 当$j\geq\pi(i)$时，接线$(i,\pi(i))$可以被加入到“不相交集合”中

上面第一种情况只是意味着接线可以被加入到集合中，而不是一定可以加入到集合中，是否允许加入到集合中还要看加入后是否存在冲突，因为定义表明冲突仅在$i'<i$且$\pi(i')>\pi(i)$时才会出现，那么，在$j=\pi(i)$时总是可以合法地加入接线$(i,j)$的（因为此时由于$j$还没有增长到$\pi(i')$，所以对于所有的$i'<i$，一定有$\pi(i')<j=\pi(i)$​），也就是有
$$
\text{size}[i][j]=
\begin{cases}
\text{size}[i-1][j] & j<\pi(i)\\
\max\{\text{size}[i-1][j],\text{size}[i-1][\pi(i)-1]+1\} & j\geq\pi(i)
\end{cases}
$$
 其中对应于$j\geq\pi(i)$的这种情况中的$\text{size}[i-1][\pi(i)-1]$中的第二维$\pi(i)-1$保证了新接线$(i,\pi(i))$一定可以加入到集合中，至于是否加入则需要一个判断（看加入后是否可以使$\text{size}$值更大）。

这样就得到了最优值，如何根据这个最优值得到究竟哪些接线在其中呢？使用和“最长公共子序列”中类似的思路，引入一个`ans_from[i][j]`来标记解的来源，从而方便回溯：

- `ans_from[i][j]=1`说明$j<\pi(i)$，接线$(i,\pi(i))$不允许加入
- `ans_from[i][j]=2`说明$j\geq\pi(i)$，接线$(i,\pi(i))$允许加入但没有加入
- `ans_from[i][j]=3`说明$j\geq\pi(i)$，即接线$(i,\pi(i))$允许加入且加入

根据上面的分析可以写出相应的代码。



## 流水作业调度

> 有$n$个作业需要依次在两台机器$M_1$和$M_2$上完成工作，第$i$个任务在机器$M_1$上的所需加工时间为$a_i$、在机器$M_2$上的所需加工时间为$b_i$，试确定$n$任务的执行顺序，使得从第一个任务进入机器$M_1$到最后一个任务离开机器$M_2$的总的加工时间最短

衡量标准显然是总执行时间，那么如何描述这个执行时间？由于任务的执行顺序是不确定的，那么干脆假定任务的执行顺序为$\pi$。我们知道对于第一台机器而言，任务总可以连续输入，即第一台机器不存在“等待时间”，而第二台机器由于需要等待第一台机器将任务送达，因此可能存在等待时间，也可能因为第二台机器执行过慢(或第一台机器执行过快）导致任务积压。

现设二元函数$\text{time}(S,t)$表示第一台机器的剩余任务集为$S$且时间$t$后第二台机器才会空闲（允许输入新任务)，那么$\text{time}(N,0)$就表示所有$n$个任务输入之前期望得到的总处理时间的最小值。

输入第一个任务时，第二台机器$M_2$是立即可用的，因此
$$
\text{time}(N,0)=\min_{i\in N}\{a_i+\text{time}(N-\{i\},b_{i})\}
$$
现在推广：当仍有$S$规模的任务等待输入到机器$M_1$时且机器$M_2$还需要$t$时间才能变成空闲状态的时候，这个$S$规模的任务所需的总时间为
$$
\text{time}(S,t)=\min_{i\in S}\{a_i+\text{time}(S-\{i\},b_i+\max(t-a_i,0))\}
$$
根据这个式子便可以进行求解，（初态设为当$S=\phi$的时候，$\text{time}(\phi,t)=t$。**这里有问题？**）

存在下面的优化方案。

***Johnson不等式***

假设$i$和$j$为$\pi$中相邻的两项，则展开可得：
$$
\begin{align}
\text{time}(S,t)&=a_i+\text{time}(S-\{i\},b_i+\max(t-a_i,0))\\
&=a_i+a_j+\text{time}(S-\{i,j\},t_{ij})
\end{align}
$$
其中
$$
\begin{align}
t_{ij}&=b_j+\max\{b_i+(\max(t-a_i,0)-a_j),0\}\\
&=b_j+\max\{\max(t-a_i,0)+b_i-a_j,0\}\\
&=b_j+b_i-a_j+\max\{\max(t-a_i,0),a_j-b_i\}\\
&=b_j+b_i-a_j+\max(t-a_i,0,a_j-b_i)\\
&=b_j+b_i-a_j-a_i+\max(t,a_i,a_i+a_j-b_i)
\end{align}
$$
如果作业$i$和$j$满足$\min(b_i,a_j)\geq\min(b_j,a_i)$，则称作业$i$和$j$满足Johnson不等式（如果不满足则交换$i$和$j$的顺序使其满足Johnson不等式）。

现在来看Johnson不等式的意义。假设交换$i$和$j$，则可以得到另一种执行顺序，在该执行顺序下，有
$$
\text{time}(S,t)=a_j+a_i+\text{time}(S-\{j,i\},t_{ji}),\quad t_{ji}=b_i+b_j-a_i-a_j+\max(t,a_j,a_j+a_i-b_j)
$$
当满足Johnson不等式时，有（$ij$顺序的）$\text{time}(S,t)$小于（$ji$顺序的）$\text{time}(S,t)$，因此这条标准可以作为规划作业执行顺序的标准。也就是说，最终得到的执行顺序应当满足：对于作业集$N$中的任意两个相邻作业$i$和$j$，都必须满足Johnson不等式，如果不满足则交换$i$和$j$的执行顺序（在作业集$N$中的位置），直到作业集$N$中作业的顺序不再变化。

利用上面分析得到的Johnson不等式的思路，可以求解此问题。



## 最优二叉搜索树

> 现有一个有序集$S=\{x_1,x_2,\cdots,x_n\}$，并构建满足下列条件的一颗二叉搜索树：
>
> 1. （内部）节点中存储有序集中的一个数字，且该数字大于其左子树中所有节点存储的数字、小于其右子树中所有节点存储的数字
> 2. 约定$x_0=-\infty$以及$x_{n+1}=+\infty$，且叶节点描述的是形如$(x_i,x_{i+1})%$（其中$i=0,1,\cdots,n$）的开区间，这样做的目的是使无论查询的数字是什么，最终总可以在树上找到对应的节点
>
> 对于有序集中的每个数字有权重$b_{1,2,\cdots,n}$，对于每个开区间有权重$a_{0,1,\cdots,n}$，试构建一颗最优二叉搜索树，使得平均访问路长$p=\sum_{i=1}^n b_i(1+c_i)+\sum_{j=0}^n a_id_j$（其中$c_i$为有序集中第$i$个数字$x_i$的节点深度、$d_j$为第$j$个开区间$(x_j,x_{j+1})$的节点深度）最小

取有序集中的连续数字串$x_i,\cdots,x_j$，假设这部分的数字可以构成最优二叉搜索（子）树，那么更大规模的连续数字串可以在此基础上去构建更大规模的最优二叉搜索树。该问题具有最优子结构性质，也就是说一个较大规模的最优二叉搜索树中一定包含较小规模的最优二叉搜索树，如果不然，则说明较大规模中的较小规模子树可以进行优化，然后可以用这个优化后的结果去替换原先的较小规模子树，这样就得到了一个更优的小规模二叉搜索树。

可以选定衡量标准为平均访问路长，并引入`avg_length[i][j]`表示从$i$到$j$的平均访问路长，则有
$$
\text{avg\_length}[i][j]=1\cdot w_{i,j}+\min_{i\leq k\leq j}(w_{i,k-1}\cdot p_{1,k-1}+w_{k+1,j}\cdot p_{k+1,j})
$$
其中$w_{i,j}=a_{i-1}+b_i+\cdots+b_j+a_j$，$p_{i,j}$的含义是从$i$到$j$的平均访问路长。使用自底向上方法以及与矩阵连乘问题类似的思路，较大规模的问题由较小规模的子问题构成，因此循环的最外层对长度从$1$到$n$进行遍历，内部第一重循环则对起始位置$i$进行遍历，内部第二重循环则对中断点$k$进行遍历，得到最优的中断点$k$之后可以记录在二维数组`seg_pos[i][j]`中，表示从$i$到$j$的这串数字应当在何处断开（构造出左右两棵子树）。





## 独立任务最优调度

> 现有$n$个任务，以及两台机器$M_1$和$M_2$，第$i$个任务在两台机器上的处理时间分别为$a_i$和$b_i$，每个任务依次输入，且可以独立地分配给任何一个机器进行处理，试求解此问题，使得从第一个任务进入机器到最后一个任务出机器的总时间最短

看到这个题，一个非常朴素的思路就是参考流水作业调度，设三维数组`time[n][i][j]`表示当前还有$n$个任务（设任务总数为$n_{\text{total}}$）、机器$M_i$经过$i$时间后可以接受当前任务输入、机器$M_2$经过$j$时间后可以接受当前任务输入的总处理时间，那么有
$$
\text{time}[n][i][j]=\min(\text{time}[n-1][i+a_{n_{\text{total}}-n+1}][j],\text{time}[n-1][i][j+b_{n_{\text{total}}-n+1}])
$$
问题的初始状态为`time[n][0][0]`，表示还有$n$个任务需要处理且$M_1$和$M_2$可以立刻接受输入。该问题的初态应当设为`time[0][i][j]=max(i,j)`，然后便可以递归求解这个问题（见对应的源文件）。

除了递归，从这个式子也可以使用动态规划方法进行处理，只需要注意初态设为`time[0][i][j]=max(i,j)`，代码见对应的源文件，这个思路还凑合，但是有两处局限性：

1. 三维数组不能过大，过大则无法运行，导致其所能处理的问题规模有限
2. 由于必须显式指定最大可能的总执行时间，导致其所能处理的问题规模受限

书上的答案的思路是先计算出时间上限：$t_{\max}=n\cdot\max(\max_{1\leq i\leq n}\{a_i\},\max_{1\leq i\leq n}\{b_i\})$，然后据此进行动态规划，然后将我的”加法“思路换成了”减法“思路进行求解，详见源代码。



## 最优批处理

> 现有$n$个作业（第$i$个作业所需完成时间为$t_i$）和一台计算机，任务是将这$n$个作业分成若干批，每一批中是连续的若干个作业，每一批作业同时输入计算机，每批作业在计算机正式处理之前需要等待$S$时间，并且每批任务同时完成（例如，当$i,\cdots,j$作业输入计算机后，这些作业经过$\sum_{k=i}^jt_k$后同时完成）且第$i$个作业完成费用是完成的时间乘以权重$f_i$，试求这些作业的一种分批方式，使总的完成费用最小

采取和上一题类似的思路，设二维数组`cost[n][t]`表示剩余$i$个任务并且等待时间$j$后才可以输入计算机时的最小的总费用，则有
$$
\text{cost}[n][t]=\min_{1\leq k\leq n}(\text{cost}[n-k][t+S+\sum_{i=n-k+1}^{n}t_i]+(S+\sum_{i=n-k+1}^{n}t_i)\cdot(\sum_{i=n-k+1}^{n}f_i))
$$
并且初始化为`cost[0][t]=t`，这和上一题是非常相似的，因此同样有动态规划和递归两种解法。

下面来看一种优化方案。

对于“寻求最优的中间断开点”这一类动态规划问题，有时可以归结为下面的模型：
$$
g(i)=
\begin{cases}
0 & i=0\\
a_i+\min_{0\leq j<i}\{g(j)+b_j+c_id_j\} & 1\leq i\leq n
\end{cases}
$$
目标就是找出从$0$到$i$中间的最优断开点$j$，这一问题通常的思路是线性搜索并进行比较，这使得问题总的复杂度为$O(n^2)$，现在来看一种优化方案：
$$
m_i=\min_{0\leq j<i}\{g(j)+b_j+c_id_j\}
$$
取$\min$表达式中的部分，记为以$c_i$为变量的函数
$$
\begin{cases}
y_j(x)=g(j)+b_j+d_jx\\
f_i(x)=\min_{0\leq j<i}\{y_j(x)\}
\end{cases}
$$
如果能快速求出$f_i(c_i)$的值，那么就能够快速得到$m_i$的值，也就快速得到了$g(i)$的最优值。现在来观察$f_i(x)$这个函数有什么特点？首先来看函数$y_j(x)$，随着$j$的不断变化，$y_j(x)$在平面上构造出了一组直线束，而$f_i(x)$则是这组直线束中的各段拼接而成的，画草图可以发现，$f_i(x)$的图像最终一定呈现出分段且“倒U”的特点。

这样，在给定$f_i(x)$表达式的前提下，只需要简单地输入$c_i$便可以得到$m_i$的值，故现在的任务就是高效地构建和维护$f_i(x)$的表达式，一旦这一点可以实现，那么上面的分析过程就可以付诸实践。

回到$f_i(x)$的图像，可以发现，每一分段（即$y_j(x)$）的斜率是递减的（从大于零、到接近零、再到小于零），这一特点非常重要，这使我们可以通过记载斜率的次序来记载分段的次序。

现在来看如何生成$f_i(x)$的图像。假设我们已经有了$f_{i-1}(x)$的图像，现在有一组新输入的数据$(g(i),b_i,d_i)$（即决定$y_i(x)$的那几个参数），如何在$f_{i-1}(x)$图像的基础上构建出$f_i(x)$图像？应当按照以下思路进行讨论：

首先利用$d$的单调性查找$d_i$可能的插入位置，然后有以下情况：

1. $d_i<d_t$（$t=1,2,\cdots,i-1$）或者$d_i>d_t$（$t=1,2,\cdots,i-1$），说明$y_i(x)$与$f_{i-1}(x)$只有一个交点，此时对于$d$序列的修改在两端进行，以$d_i<d_t$这种情况为例，查找位于$d_i<d_t$上方的最左交点，位于此最左交点右侧的点（所在的线段）将全部被“剔除”
2. 否则，说明$y_i(x)$与$f_{i-1}(x)$可能有两个交点，此时存在两条线的斜率将此线段的斜率“夹在中间”，至于$y_i(x)$是否应该加入到图像中则取决于那两条线交点在$y_i(x)$是上方还是下方：交点在下方则$y_i(x)$不需要加入、交点在上方则$y_i(x)$需要加入，如果加入，则进一步查找位于$y_i(x)$上方的最左交点和最右交点，如果没有则说明新加入的$y_i(x)$不会导致已有线段被“剔除”、如果有则说明已有线段需要被“剔除”

这样就描述完毕了相关的基本思想，为了将此基本思想进一步实现，我们可以选择多种实现载体，只需要注意这种实现载体必须能够高效维护$d$序列以及相应的交点序列，并且可以保存函数$f_{1,2,\cdots,n}(x)$的描述，而且在输入$x=c_i$之后可以很快地（理想复杂度显然是$O(1)$）求解出对应的解。



## 线性石子合并

> 现有$n$堆石子，第$i$堆有$n_i$个石子，每次可以选择相邻的两堆石子进行合并，每次合并的花销为合并后石子的数量，试求出最小总花销和最大总花销？

引入二维数组`cost[i][j]`表示合并从$i$到$j$堆的石子的总花销，则有
$$
\text{cost}[i][j]=\max_{i\leq k\leq j}/\min_{i\leq k\leq j}\{(\text{cost}[i][k]+\text{cost}[k][j]),(\text{cost}[j][k]+\text{cost}[k][i])\}+\text{sum}[i][j]
$$
这又是一个类似于“最优断开点”的问题，代码见对应的源文件。注意初始化条件。

在代码中，前缀和`sum[i]`是非常使用的，在很多题目中都有很好的用处。



## 环形石子合并

> 现有$n$堆石子，第$i$堆有$n_i$个石子，且这$n$堆石子首尾相连（排成一个环），每次可以选择相邻的两堆石子进行合并，每次合并的花销为合并后石子的数量，试求出最小总花销和最大总花销？

和上一题唯一的区别就在于引入了“环形”概念，初看似乎需要使用取模运算，但取模运算非常容易出错，下面介绍一种对环形问题往往都有很好处理效果的思路。

对于长度为$n$的序列$(1,2,\cdots,n)$，因为允许环形访问，所以有下面这些等价表示：

- $(1,2,3\cdots,n-2,n-1,n)$
- $(n,1,2\cdots,n-3,n-2,n-1)$
- $(n-1,n,1,2\cdots,n-4,n-3,n-2)$
- $\dots$

因此实际上长度为$n$的序列$(1,2,\cdots,n)$其实是长度为$2n$的序列$(1,2,\cdots,n,1,2,\cdots,n-1)$中长度为$n$的子序列，这样我们就将环形石子合并转换成了线性石子合并，原问题就变成了：在这个长度位$2n$的序列中，所有长度为$n$的子序列里，最大总花销和最小总花销是多少，这样我们就可以遍历长度为$n$的子序列的起始位置，从而观察最大总花销和最小总花销各是多少。

朴素写法是容易实现也是直观的，但是复杂度为$O(n^3)$（我的源代码中使用了四重循环，三重循环的版本详见答案书），现在来介绍一种称为“平行四边形不等式”的结论，该结论可以将“寻求最优中间断点”问题进行优化。如果二维动态规划数组`dp[i][j]`满足
$$
\text{dp}[a][c]+\text{dp}[b][d]\leq \text{dp}[b][c]+\text{dp}[a][d]\quad\text{即}\quad\text{dp}[i][j-1]\leq\text{dp}[i][j]\leq\text{dp}[i+1][j]
$$
通常寻找“最优中断点”需要遍历从$i$到$j$的所有位置，这导致算法复杂度为$O(n^3)$，而如果二维动态规划数组满足平行四边形不等式，则只需要遍历从$\text{seg}[i][j-1]$到$\text{seg}[i+1][j]$这部分中的点（$\text{seg}[i][j]$表示从$i$到$j$的最优中断点），这样就将算法复杂度降到了$O(n^2)$（严格来讲比$O(n^2)$大一点点，是这样吗？）。

该问题还有一种复杂度更低的算法：GarsiaWachs算法，详见：[石子合并-CSDN博客](https://blog.csdn.net/weixin_30497527/article/details/101446414)。



## 不相邻石子合并

> 现有$n$堆石子，第$i$堆有$n_i$个石子，每次可以选择任意的两堆石子进行合并，每次合并的花销为合并后石子的数量，试求出最小总花销和最大总花销？

每次选择最小的两堆石子进行合并即可，这题本质上是最简单的哈夫曼问题。



## 数字三角形

> 给定一个由$n$行数字组成的三角形，第$i$行有$i$个数字（最上面为第$1$行），试设计一条从上到下的路径，使途经数字的总和最大

设二维数组`dp[i][j]`表示到达第$i$行第$j$个数字时的最大总和，那么有
$$
\text{dp}[i][j]=\max\{\text{dp}[i-1][j],\text{dp}[i-1][j-1]\}+\text{num}[i][j]
$$
容易求解，详见对应的源代码。如果要构建路径的话，也是容易的，只需要另建一个二维数组`ans_from[i][j]`表示第$i$行第$j$列对应的`dp[i][j]`是从第$i-1$行的哪一个元素转移而来的即可。



## 乘法表

> 定义一种特殊的乘法运算如下：
>
> ```
>   * | a | b | c |
> --+---+---+---+
> a | b | b | a |
> --+---+---+---+
> b | c | b | a |
> --+---+---+---+
> c | a | c | c |
> --+---+---+---+
> ```
>
> 并给定一个字符串作为输入，试求有多少种加括号方式可以使结果等于a？

简单，一看就简单，只需要引入三个二维数组：

- `ans_a[i][j]`表从第$i$个输入字符到第$j$个输入字符的乘法结果有多少种等于`a`
- `ans_b[i][j]`表从第$i$个输入字符到第$j$个输入字符的乘法结果有多少种等于`b`
- `ans_c[i][j]`表从第$i$个输入字符到第$j$个输入字符的乘法结果有多少种等于`c`

如果要求输出每种加括号方式呢？如何解决？





## 租用游艇

> 从一条江的上游到下游依次有$n$个游艇出租站$1,2,\cdots,n$，游客可以在上游的任一个出租站租用游艇，并在下游的任一个出租站归还游艇，从第$i$个出租站到第$j$个出租站所需的租金是$r(i,j)$，试求出从第一个出租站到最后一个出租站所需的最小费用？

引入一个二维数组`rent[i][j]`表示从第$i$个出租站到第$j$个出租站所需的最小租金，则有
$$
\text{rent}[i][j]=
\begin{cases}
r[i][j] & j=i+1\\
\min_{i\leq k\leq j}\{\text{rent}[i][k]+\text{rent}[k+1][j]\} & j>i+1
\end{cases}
$$
据此进行动态规划即可求解问题，需要注意的是，这题不是在空二维数组上进行动态规划的，而是在输入的二维数组`rent[i][j]`上进行动态规划的，这就使得我们可以直接通过修改`max/min`来求解最大或最小值（如源代码所示），而如果在一个空的二维数组上进行动态规划的话，并不是这么方便。



## 汽车加油

> 给定一个$N\times N$的网格，左上角为起点$(1,1)$，右下角为终点$(N+1,N+1)$，在某些网格交叉处设置了加油站（起点和终点不设加油站），汽车从起点向终点行进时遵循：
>
> 1. 只能沿网格边行驶，加满油可以行驶$K$长度
> 2. 当汽车行驶经过一条网格边时，若其坐标减小，则应支付费用$B$
> 3. 汽车出发时已经加满了油
> 4. 汽车在行驶中若遇加油站则加满油且支付费用$A$
> 5. 汽车在行驶中若用完油则需要支付费用$C+A$来加满油以便于继续前进
>
> 以上涉及到的数字均为整数，试求出一条路线，使总费用最小

设数组`f[i][j][0]`表示行进到$(i,j)$处的最小花销、数组`f[i][j][1]`表示行进到$(i,j)$处还能向前行驶的距离，那么有：
$$
\begin{align}
\text{起始情况}~~~~ & f(1,1,0) = 0,\quad f(1,1,1) = K\\
(x,y)\text{是加油站}~~~~ & f(x,y,0) = f(x,y,0) + A,\quad f(x,y,1) = K\\
(x,y)\text{不是加油站且}f(x,y,1)=0~~~~ & f(x,y,0) = f(x,y,0) + C + A,\quad f(x,y,1) = K\\
\text{正常情况}~~~~ & f(x,y,0) = \min_{0\leq i\leq 4}\{f(x+s[i][0],y+s[j][1],0)+s[i][2]\}\\
\text{正常情况}~~~~ & f(x,y,1) = f(x+s[j][0],y+s[j][1],1)-1
\end{align}
$$
其中`s={{-1,0,0},{0,-1,0},{1,0,B},{0,1,B}};`。上面这题中一个很重要的技巧就是`s`数组的引入，在类似的“四方向上的转移”这种题目中，`s`数组是很常见的小技巧，可以提高程序的可读性，且使思路变得清晰。



## 最小$m$段和

> 给定$n$个整数组成的序列，现在要求将序列分成$m$段（每个子序列中的数在原序列中是连续的），问如何分段可以使这$m$段序列和的最大值达到最小？

初看这道题目是比较迷糊的，但分析就可以知道，题意是说将$n$个整数切分成$m$段，并且第$i$段的和为$\text{sum}_{i=1,2,\cdots,m}$，现在对这$m$个和进行分析，取出其中的最大值，并使这个最大值最小。引入二维数组`min_max[i][j]`表示将前$i$个数字分成$j$段的和的最大值的最小值，那么有如下的转移方程：
$$
\begin{align}
\text{min\_max}[i][1]&=\text{前}i\text{个数字的和（前缀和）}\\
\text{min\_max}[i][j]&=\min\{\max_{1\leq k\leq i}\{\text{min\_max}[k][j-1],\text{min\_max}[i][1]-\text{min\_max}[k][1]\}\}
\end{align}
$$
第二种情况内部的$\max$产生出了$i$种情况下的最大值，外侧的$\min$则从这$i$种情况下的最大值中选出了最小值。为了求出分段情况，同样使用二维数组`ans_from[i][j]`进行辅助求解。



## 最大长方体

> 现有一个长、宽、高分别为$m$、$n$、$p$的长方体被分为$m\times n\times p$个小正方体，每个小正方体内有一个整数（当然可以是负数！），试计算该长方体的最大子长方体（子长方体的大小由其中整数求和得到）

引入一个三元数组`max_sum[i][j][k]`表示以坐标$(i,j,k)$作为结束的长方体中的最大子长方体，则可以写出如下所示的递归关系式：
$$
\begin{align}
\text{max\_sum}[m][n][p]=\max\{&\text{max\_sum}[m-1][n][p]+\text{sum}[m][n][p]-\text{sum}[m-1][n][p],\\
&\text{max\_sum}[m][n-1][p]+\text{sum}[m][n][p]-\text{sum}[m][n-1][p],\\
&\text{max\_sum}[m][n][p-1]+\text{sum}[m][n][p]-\text{sum}[m][n][p-1]
\}
\end{align}
$$
其中，三维数组`sum[i][j][k]`表示从坐标为$(1,1,1)$到坐标为$(i,j,k)$的小正方体中的整数和，根据容斥原理，得到：
$$
\text{sum}[i][j][k]=\text{sum}[i-1][j-1][k-1]+\text{sum}[i-1][j][k]-\text{sum}[i-1][j][k-1]+\text{sum}[i][j-1][k]-\text{sum}[i-1][j-1][k]+\text{sum}[i][j][k-1]-\text{sum}[i][j-1][k-1]+\text{cuboid}[i][j][k]
$$
然后扫描三维数组`max_sum[i][j][k]`找出最大值即可，代码详见源文件。



## 最少费用购物

> 商店内每种物品都有标价，例如一朵花$2$元，一个花瓶为$5$元，但是该商店允许搭配优惠，例如，三朵花为$5$元而非$6$元、两个花瓶和一朵花为$10$元而非$12$元，等等。现在给出每位顾客所购商品的种类和数量，试计算该顾客所需的最少费用（各种数据限制见书本要求）

题目中提到购物实际上两种可选的方案：使用搭配获得优惠或者单独购买，如何将这两种方案进行统一呢？一个合适的想法就是将单独购买作为一种特殊的搭配购买方案，因此，我们引入如下所示的数组，用来表示优惠方案：

- `kind[i]`：表示第$i$种搭配方案中涉及到多少种商品
- `num[i][j]`：表示在第$i$种搭配方案中第$j$种物品的数量
- `cost[i]`：表示第$i$种搭配方案的售价

这样，对于单件商品，我们可以令`kind[i]=1`、`num[i][1]=1`以及`cost[i]=商品单价`。题目限制了总的采购数量不超过五种商品，那么我们可以使用五维数组来进行动态规划，引入`dp[i][j][k][m][n]`表示第一种欲购商品买$i$件、第二种预购商品买$j$件、第三种预购商品买$k$件、第四种预购商品买$m$件、第五种预购商品买$n$件时的最小花销，则有：
$$
\text{dp}[i][j][k][m][n]=\min_{1\leq x\leq N}\{\text{dp}[i-\text{num}[x][n_1]][j-\text{num}[x][n_2]][k-\text{num}[x][n_3]][m-\text{num}[x][n_4]][n-\text{num}[x][n_5]]+\text{cost}[x]\}
$$
其中$\{n_1,n_2,n_3,n_4,n_5\}$表示当前想要购买的五种商品的序号（如果不足五种则补零），$x$表示第几个促销方案（设共有$N$个）。根据上面的分析可以写出代码，详见对应的源文件，注意`dp`数组的初始化！





## *参考资料

1. 王晓东，《计算机算法设计与分析》，2018
2. 崔天翼，《背包问题九讲 2.0》，2012
