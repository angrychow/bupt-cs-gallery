2022/11/20

# 贪心算法

rongtianfu@gmail.com

## 思路简述

贪心算法似乎可以理解为动态规划算法的一种效率比较高的近似？

需要注意的是，贪心算法并不一定保证得到全局最优解，但是我们可以从事实的观测中得出，如果满足以下两个特点，那么对于这道题，贪心算法就是可以得到全局最优解的：

1. 贪心选择性质：只需要基于当前情况做出最优解，即可保证全局最优解。但是，在动态规划算法中，当前状态的最优解与子问题的解具有非常强的关联性，不能仅根据当前问题的性质得到解。如何证明这一性质？常见的思路是：假设有一个当前问题的最优解，如果能找到一个执行方案，使这个最优解以某种角度上的”贪心选择“作为开始，并据此将问题划分为更小规模的问题，那么就可以证明贪心选择性质
2. 最优子结构性质：这个问题的整体最优解包括子问题的最优解，也就是说，如果得到了当前问题的最优解，那么如果将当前问题切分成小规模的子问题，那么可以直接得到小规模子问题的最优解



## 活动安排

> 设有$n$个活动的集合$E=\{1,2,\cdots,n\}$，其中每个活动都需要使用同一资源，而在同一时间内只有一个活动可以使用这个资源。每个活动都有开始时间$s_i$和结束时间$f_i$，该活动在区间$[s_i,f_i)$内占有这个资源，试在活动集合中选择出可以使总活动数最多的活动子集合并给出安排方案

这道题可以使用贪心算法来进行求解，即：每次选择活动的时候总是选择结束时间$f_i$最早的活动，从而为接下来的活动预留最多的时间。虽然贪心算法并不一定能够得到全局最优解，但是对于这个问题而言，却总是可以得到全局最优解的，这可以由书上所示的数学归纳法进行证明。

代码见相应的源文件。



## 背包问题

> 给定$n$种物品和容量为$C$的背包，第$i$件物品的价值为$w_i$、所需空间为$c_i$，01背包问题是说从中挑选物品放入背包使总价值最大，但这里的问题是：在选择物品放入背包时，可以放入第$i$件物品的一部分，而不需要全部放入，试求解此问题

看似比较复杂，但实际上有一个很简单的贪心思路可以求解这个问题：计算每种物品的单位价值$w_i/c_i$，从高到低依次选择单位价值最高的物品进行放入，若还有剩余空间则选择后续的物品。



## 最优装载

> 有一批集装箱要装上一艘载重为$C$的轮船，第$i$个集装箱的重量为$w_i$，要求将尽可能多的集装箱装上轮船

很显然，为了装入尽可能多的集装箱，需要先将集装箱按照重量从小到大进行排序，然后选择前面的若干个集装箱（直到装满为止），在具体实现上可以使用前缀和进行求和并与总载重量进行比较，详见源代码。



## 哈夫曼编码

> 哈夫曼算法根据字符在文件中的使用次数选择一种使用$0$和$1$的编码方式，使总所需存储空间最小，为了简化问题，这里假定文件中一共只出现前$6$个字母

一个直观的思路就是给出现频率高的字母更短的编码、而给出现频率低的字母更长的编码，这样便可以使总存储空间向更小趋近。由于要求以$0$和$1$来构造编码，因此可以采用“前缀码”的思路进行编码，并使用二叉树进行构造。在构造的时候采取自底向上的思路，每次选择“频率最低”的两棵子树进行合并，直到最后得到一棵完整的二叉树。

代码见相应的源文件。



## 最优服务次序

> 设有$n$名顾客同时等待一项服务，顾客$i$需要的服务时间为$t_i$，问如何安排$n$个顾客的访问次序使总的平均访问时间最小？

显然应当采取贪心算法，假定有一种活动安排方案$\{t_1,t_2,\cdots,t_n\}$使总的平均等待时间最小，那么这$n$个活动一定按照所需的活动时间非递减进行排序，下面来证明这一结论。

使用反证法，假设$n$个活动不按照非递减顺序进行排序是最优解，则存在$1\leq i,j\leq n$且$i<j$，使得$t_i>t_j$，那么总的平均等待时间
$$
\begin{align}
\bar{t}_{\text{总1}}&=\frac1n[(t_1)+\cdots+(t_1+\cdots+t_i)+\cdots(t_1+\cdots+t_i+\cdots+t_j)+\cdots+(t_1+\cdots+t_n)]\\
&=\frac1n[n\cdot t_1+(n-1)\cdot t_2+\cdots+(n-i+1)\cdot t_i+\cdots+(n-j+1)\cdot t_j+\cdots+t_n]
\end{align}
$$
如果我们交换$t_i$和$t_j$，得到$\bar{t}_{\text{总2}}$：
$$
\begin{align}
\bar{t}_{\text{总2}}&=\frac1n[(t_1)+\cdots+(t_1+\cdots+t_j)+\cdots(t_1+\cdots+t_j+\cdots+t_i)+\cdots+(t_1+\cdots+t_n)]\\
&=\frac1n[n\cdot t_1+(n-1)\cdot t_2+\cdots+(n-i+1)\cdot t_j+\cdots+(n-j+1)\cdot t_i+\cdots+t_n]
\end{align}
$$
则有
$$
\bar{t}_{\text{总1}}-\bar{t}_{\text{总2}}=(n-i+1)(t_i-t_j)+(n-j+1)(t_j-t_i)=(j-i)(t_i-t_j)>0
$$
这违背了“$n$个活动不按照非递减顺序进行排序是最优解”这一假设，因此矛盾，所以$n$个活动按照非递减顺序进行排序是最优解。

代码见相应的源文件。



## $d$森林问题

> 设$T$是一颗带权树，树的每条边带有一个正权，$S$是$T$的顶点集，$T/S$是从树$T$中将$S$中顶点删去后得到的森林。如果$T/S$中所有树从根到叶的路长都不超过$d$，则称$T/S$是一个$d$森林，设计一个算法求$T$的最小顶点集$S$，使$T/S$是$d$森林。（输入输出约定见书上相关内容）（注意，可能无解）

这道题看似比较复杂，但实际上就是从每个叶节点到根节点进行移动，只要路长超过$d$则断开，此时将下一个节点设为当前节点的爷爷节点，并且当前节点的父结点和爷爷节点都设为叶子节点，并且将当前节点的父结点设为$0$.

代码见相应的源文件。



## 区间覆盖

> 设直线上有$n$个点$\{x_1,x_2,\cdots,x_n\}$，现在用固定长度的闭区间覆盖这$n$个点，问至少需要多少个这样的固定长度闭区间？（闭区间的长度$k$通过标准输入给出）

首先将这些点按照从小到大的顺序进行排序，然后从第一个点开始扫描，并进行相应处理，采取贪心算法，每次覆盖尽可能多的点，这样可以使所用闭区间的数量最少。

代码见相应的源文件。
