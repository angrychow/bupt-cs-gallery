2022/11/18

# 递归与分治问题

rongtianfu@gmail.com

## 基本思想

直接或间接调用自身的算法（函数）称为是递归的，递归的基本思路是从最大规模的问题开始，并分析

1. 问题规模是如何缩小的？
2. 问题的最基本的情况是什么？

这两个问题，之后再理论上便可以解题。



## 整数划分

> 现有一个正整数$n$，将$n$表示成若干个正整数相加的形式$n=n_1+n_2+\cdots+n_k~(k\geq1)$称为$n$的一个划分，试对给定的任意正整数$n$，求它的划分数

设$f(n,m)$表示分段中最大数字不超过$m$的划分数，那么
$$
f(n,m)=
\begin{cases}
1 & n=1,m=1\\
f(n,n) & n < m\\
1+f(n,n-1) & n = m\\
f(n,m-1)+f(n-m,m) & n>m>1
\end{cases}
$$
据此便可以写出代码，不再赘述。



## 汉诺塔

> 设$a$、$b$、$c$是三个塔座，开始时，在塔座$a$上有$n$个从大到小、自底向上堆叠的圆盘，试按照汉诺塔移圆盘的规则，求出将者$n$个圆盘移动到塔座$b$的总移动次数？

非常经典的问题！假设将塔座$a$最上面的$n-1$个圆盘移动到了塔座$c$，那么问题就变成了：将塔座$a$上的$n-1$个圆盘移动到塔座$b$，然后再将原先最下面的那个圆盘从塔座$a$移动到塔座$b$，然后再将塔座$c$上的$n-1$个圆盘移动到塔座$b$。因此，有如下思路：
$$
\text{总次数}=\text{hanoi}(n-1,a,c,b)+\text{move}(a,b)+\text{hanoi}(n-1,c,b,a)
$$
有了这个之后，代码就是容易实现的，此处不再赘述。



## 二分搜索

> 给定一个排好序的数字序列（常见的是从小到大），如果要在其中搜索指定元素，则可以采用二分搜索的思路进行处理

即折半查找，代码见相应的源文件。



## Strassen矩阵乘法

> 给定两个$n\times n$的矩阵，如何高效计算这两个矩阵的乘法呢？

这样计算：
$$
\left[
\begin{matrix}
  C_{11} & C_{12}\\
  C_{21} & C_{22}
\end{matrix}
\right]
=
\left[
\begin{matrix}
  A_{11} & A_{12}\\
  A_{21} & A_{22}
\end{matrix}
\right]
\cdot
\left[
\begin{matrix}
  B_{11} & B_{12}\\
  B_{21} & B_{22}
\end{matrix}
\right]
$$
其中，
$$
\begin{align}
C_{11}&=A_{11}B_{11}+A_{12}B_{21}\\
C_{12}&=A_{11}B_{12}+A_{12}B_{22}\\
C_{21}&=A_{21}B_{11}+A_{22}B_{21}\\
C_{22}&=A_{21}B_{12}+A_{22}B_{22}
\end{align}
$$
通过分析，可以知道，我们实际上只需要做$7$次乘法（而不是上面所说的$8$次），如下所示：
$$
\begin{align}
M_1&=A_{11}(B_{12}-B_{22})\\
M_2&=(A_{11}+A_{12})B_{22}\\
M_3&=(A_{21}+A_{22})b_{11}\\
M_4&=A_{22}(B_{21}-B_{11})\\
M_5&=(A_{11}+A_{22})(B_{11}+B_{22})\\
M_6&=(A_{12}-A_{22})(B_{21}+B_{22})\\
M_7&=(A_{11}-A_{21})(B_{11}+B_{12})\\
C_{11}&=M_5+M_4-M_2+M_6\\
C_{12}&=M_1+M_2\\
C_{21}&=M_3+M_4\\
C_{22}&=M_5+M_1-M_3-M_7
\end{align}
$$
分析完毕。



## 棋盘覆盖

> 在一个$2^k\times 2^k$个方格组成的棋盘中，若恰有一个方格与其他方格不同，则称该方格为一个特殊方格，试使用四种形态的$L$型块来填充这个棋盘，试分析这个问题？

分析是简单的，主要就是将大棋盘按照特殊方格出现的位置划分为四个小棋盘，然后递归求解直到大小为$1\times1$的最小棋盘。具体分析此处略去，但不知道这题会怎么考？



## 合并排序

> 试使用分治策略完成数字序列的排序？

基本思路是将待排序的数字分为大小相同（或相差$1$）的两段，然后递归进行处理，详见源代码。



## 快速排序

> 复习快速排序的思路并实现快速排序？

快速排序的思路是从递归想法出发，按照以下思路进行排序：

1. 分解：以`a[p]`为基准将`a[p:r]`分成`a[p:q-1]`、`a[q]`和`a[q+1:r]`三部分，使`a[p:q-1]`中任何一个元素小于等于`a[p]`且`a[q+1:r]`中任何一个元素大于等于`a[p]`。下标`q`应当在划分过程中确定
2. 递归：对`a[p:q-1]`和`a[q+1:r]`两个部分进行递归
3. 合并：由于上述两个部分的排序是“就地进行”的，因此不需要合并步

详见源代码，这道题最重要的我感觉并不是思路，而是代码细节，尤其是`i_temp`和`j_temp`的变化以及终止递归条件的判断，非常容易错！



## 线性时间选择

> 给定$n$个元素和一个整数$k$，要求在这$n$个元素中选择出第$k$小的元素

详见书本分析和源代码文件，这题最关键的在于理论分析！











## *参考资料

1. 王晓东，《计算机算法设计与分析》，2018